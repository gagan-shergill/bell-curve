<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Interactive Normal Distribution</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">

    <style>
      body { font-family: "Poppins", system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

      @page { size: landscape; margin: 0.5in; }

      @media print {
        body * { visibility: hidden; }
        .print-keep, .print-keep * { visibility: visible; }
        .print-keep { position: static; width: 100%; margin: 0; padding: 0; }
        .print-keep .rounded-2xl { overflow: visible !important; box-shadow: none !important; border-color: #ccc !important; }
        svg { width: 100%; height: auto; }
        table { page-break-before: avoid; width: 100%; border-collapse: collapse; font-size: 10pt; }
        th, td { border: 1px solid #ccc; padding: 4px; }
        .no-print, .print-hide { display: none !important; }
      }
    </style>
  </head>

  <body class="bg-white">
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useState } = React;

      function gaussian(x, mean, sd) {
        const coef = 1 / (sd * Math.sqrt(2 * Math.PI));
        const exp = Math.exp(-0.5 * Math.pow((x - mean) / sd, 2));
        return coef * exp;
      }

      function toStd100(value, type, axisSd) {
        if (type === "standard") return value;
        if (type === "z") return 100 + value * axisSd;
        if (type === "t") return 100 + ((value - 50) / 10) * axisSd;
        if (type === "scaled") return 100 + ((value - 10) / 3) * axisSd;
        return value;
      }

      const BASE_RANGES = [
        { min: -Infinity, max: 69, tint: "#fecaca" },
        { min: 70, max: 79, tint: "#fed7aa" },
        { min: 80, max: 89, tint: "#fde68a" },
        { min: 90, max: 109, tint: "#bbf7d0" },
        { min: 110, max: 119, tint: "#bae6fd" },
        { min: 120, max: 129, tint: "#c7d2fe" },
        { min: 130, max: Infinity, tint: "#ddd6fe" },
      ];

      const BAND_LABELS = {
        en: ["Very Low","Low","Below Avg","Average","High Avg","Very High","Superior"],
        es: ["Muy Bajo","Bajo","Promedio Bajo","Promedio","Promedio Alto","Superior","Muy Superior"],
        yue: ["非常低","低","低平均水平","平均","高平均水平","高","非常高"],
      };

      // Preset palette for cluster colors (assigned automatically to new clusters)
      const CLUSTER_PALETTE = [
        "#0ea5ff", // blue
        "#6366f1", // indigo
        "#8b5cf6", // violet
        "#14b8a6", // teal
        "#22c55e", // green
        "#f59e0b", // amber
        "#f97316", // orange
        "#f43f5e", // rose
        "#334155", // slate
      ];

      // Marker color choice (persists until changed)
      // If set to "", we use the cluster's assigned color automatically.
      const MARKER_COLOR_PRESETS = [
        { label: "Auto (cluster color)", value: "" },
        { label: "Blue", value: "#0ea5ff" },
        { label: "Indigo", value: "#6366f1" },
        { label: "Violet", value: "#8b5cf6" },
        { label: "Teal", value: "#14b8a6" },
        { label: "Green", value: "#22c55e" },
        { label: "Amber", value: "#f59e0b" },
        { label: "Orange", value: "#f97316" },
        { label: "Rose", value: "#f43f5e" },
        { label: "Slate", value: "#334155" },
      ];

      function BellCurveDashboard() {
        const [axisSd, setAxisSd] = useState(15);
        const [curveColor, setCurveColor] = useState("#bfe0ff99");

        const [name, setName] = useState("");
        const [cluster, setCluster] = useState(""); // NEW: cluster/group field
        const [type, setType] = useState("standard");
        const [value, setValue] = useState("");

        const [items, setItems] = useState([]);
        const [showBands, setShowBands] = useState(false);
        const [showNumeric, setShowNumeric] = useState(true);
        const [lang, setLang] = useState("en");

        // NEW: group markers by cluster (separate vertical blocks)
        const [groupByCluster, setGroupByCluster] = useState(true);

        // NEW: persistent marker color selection
        const [markerPreset, setMarkerPreset] = useState(""); // "" = auto (cluster color)

        // Cluster color map + creation order
        const [clusterColors, setClusterColors] = useState({});  // { clusterName: "#hex" }
        const [clusterOrder, setClusterOrder] = useState([]);    // ["WISC-V", "Language", ...]

        const RANGE_BANDS = useMemo(() => {
          const labels = BAND_LABELS[lang] || BAND_LABELS.en;
          return BASE_RANGES.map((r, i) => ({ ...r, label: labels[i] }));
        }, [lang]);

        const width = 1000, leftPad = 60, rightPad = 40;
        const innerWidth = width - leftPad - rightPad;
        const xMin = 40, xMax = 160, mean = 100;

        // marker box layout
        const rowGapY = 38, boxH = 36, boxGapX = 8;
        const clusterGapY = 22; // vertical spacing between cluster blocks
        const topPad = 24, bottomPad = 70, baseHeight = 400, topRowGap = 16;

        const xScale = (x) => leftPad + ((x - xMin) / (xMax - xMin)) * innerWidth;

        const bandFor = (s) => (RANGE_BANDS.find(b => s >= b.min && s <= b.max) || {}).label || "";

        // Assign a new color to a new cluster name
        function ensureClusterColor(clusterName) {
          const clean = (clusterName || "").trim();
          const key = clean || "Ungrouped";
          if (clusterColors[key]) return { key, color: clusterColors[key] };

          // pick next palette color (cycle if needed)
          const nextIdx = clusterOrder.length % CLUSTER_PALETTE.length;
          const nextColor = CLUSTER_PALETTE[nextIdx];

          setClusterColors(prev => ({ ...prev, [key]: nextColor }));
          setClusterOrder(prev => (prev.includes(key) ? prev : [...prev, key]));

          return { key, color: nextColor };
        }

        const addItem = (e) => {
          e.preventDefault();
          const num = Number(value);
          if (!isFinite(num)) return;

          const std100 = toStd100(num, type, axisSd);

          // ensure cluster exists + has a default color
          const { key: clusterKey, color: clusterColor } = ensureClusterColor(cluster);

          // choose item color:
          // - if markerPreset is set, use it
          // - else use clusterColor (auto)
          const itemColor = markerPreset ? markerPreset : clusterColor;

          setItems(prev => [
            ...prev,
            {
              id: Math.random().toString(36).slice(2),
              name: name.trim() || "(Unnamed)",
              cluster: clusterKey,
              inputType: type,
              inputValue: num,
              std100,
              color: itemColor,
            }
          ]);

          setName("");
          setValue("");
          // keep cluster + markerPreset persistent until user changes them
        };

        const removeItem = (id) => setItems(prev => prev.filter(i => i.id !== id));

        // --- Layout computation ---
        // If grouping is ON:
        //  - each cluster gets its own row-packing (no mixing)
        //  - clusters are stacked vertically, preserving clusters intact
        const layout = useMemo(() => {
          const getBoxW = (label) => Math.max(84, String(label).length * 6 + 24);

          // helper: pack one cluster's items into rows (no overlap in the same row)
          function packRows(clusterItems) {
            const sorted = [...clusterItems].sort((a,b) => a.std100 - b.std100);
            const rowsRight = [];
            const placed = [];

            sorted.forEach((it) => {
              const x = xScale(it.std100);
              const boxW = getBoxW(it.name);
              const proposedX = Math.max(
                leftPad + 4,
                Math.min(x - boxW / 2, leftPad + innerWidth - boxW - 4)
              );

              let row = 0;
              while (true) {
                const rightEdge = rowsRight[row] ?? (leftPad - boxGapX);
                if (proposedX >= rightEdge + boxGapX) {
                  rowsRight[row] = proposedX + boxW;
                  placed.push({ ...it, boxW, x: proposedX, row });
                  break;
                }
                row += 1;
              }
            });

            return { placed, rows: Math.max(1, rowsRight.length) };
          }

          // no grouping: one pack for all items
          if (!groupByCluster) {
            const { placed, rows } = packRows(items);
            const totalRows = rows;
            return {
              totalRows,
              clusters: [
                { name: "__all__", rows, placed: placed.map(p => ({ ...p, clusterYOffset: 0 })) }
              ]
            };
          }

          // grouping: pack per cluster, then stack clusters
          const clustersMap = new Map();
          items.forEach((it) => {
            const key = it.cluster || "Ungrouped";
            if (!clustersMap.has(key)) clustersMap.set(key, []);
            clustersMap.get(key).push(it);
          });

          // stable cluster order: creation order first, then any stragglers
          const orderedClusters = [
            ...clusterOrder.filter(c => clustersMap.has(c)),
            ...[...clustersMap.keys()].filter(c => !clusterOrder.includes(c)).sort()
          ];

          let yOffsetRows = 0;
          const clusterLayouts = [];
          orderedClusters.forEach((cname, idx) => {
            const { placed, rows } = packRows(clustersMap.get(cname));
            const clusterYOffsetPx = yOffsetRows * rowGapY + (idx === 0 ? 0 : clusterGapY);
            clusterLayouts.push({
              name: cname,
              rows,
              yOffsetPx: clusterYOffsetPx,
              placed: placed.map(p => ({ ...p, clusterYOffsetPx }))
            });
            // next cluster starts after this cluster's rows (plus gap handled above)
            yOffsetRows += rows;
          });

          const totalRows = yOffsetRows;
          return { totalRows, clusters: clusterLayouts };
        }, [
          items, groupByCluster, clusterOrder, innerWidth,
          leftPad, boxGapX, rowGapY, clusterGapY
        ]);

        // Dynamic height: expand from bottom to fit all cluster rows
        const height = useMemo(() => {
          const required =
            topPad +
            topRowGap +
            (layout.totalRows * rowGapY) +
            boxH +
            bottomPad +
            // extra bottom breathing room if lots of clusters
            (groupByCluster ? 10 : 0);

          return Math.max(baseHeight, required);
        }, [layout.totalRows, groupByCluster]);

        const innerHeight = height - topPad - bottomPad;

        const pathD = useMemo(() => {
          const steps = 300;
          let maxY = 0;
          const xs = [], ys = [];
          for (let i = 0; i <= steps; i++) {
            const x = xMin + (i * (xMax - xMin)) / steps;
            const y = gaussian(x, mean, axisSd);
            xs.push(x); ys.push(y);
            if (y > maxY) maxY = y;
          }
          const scaleY = (y) => topPad + innerHeight - (y / maxY) * innerHeight;

          let d = "";
          for (let i = 0; i <= steps; i++) {
            const X = xScale(xs[i]);
            const Y = scaleY(ys[i]);
            d += i === 0 ? `M ${X} ${Y}` : ` L ${X} ${Y}`;
          }
          d += ` L ${xScale(xMax)} ${topPad + innerHeight} L ${xScale(xMin)} ${topPad + innerHeight} Z`;
          return d;
        }, [axisSd, innerHeight]);

        // Show cluster name labels on the left when grouping
        function renderClusterLabels() {
          if (!groupByCluster) return null;
          return layout.clusters.map((c, idx) => (
            <text
              key={c.name}
              x={leftPad - 10}
              y={topPad + 16 + c.yOffsetPx + 12}
              textAnchor="end"
              className="fill-slate-500 text-[11px]"
            >
              {c.name}
            </text>
          ));
        }

        return (
          <div className="w-full min-h-screen bg-white text-slate-800 p-6">
            <div className="max-w-[1200px] mx-auto">
              <h1 className="text-2xl md:text-3xl font-semibold mb-2 print-hide">
                Interactive Normal Distribution
              </h1>

              <div className="grid lg:grid-cols-3 gap-4 mb-6 print-hide">
                <div className="p-4 rounded-2xl bg-white shadow-sm border">
                  <div className="flex items-center justify-between mb-3">
                    <span className="font-medium">Axis standard deviation</span>
                    <div className="flex items-center gap-2">
                      <button
                        className={`px-3 py-1 rounded-full border ${axisSd===15?"bg-slate-900 text-white":"bg-white"}`}
                        onClick={()=>setAxisSd(15)}
                        type="button"
                      >
                        15
                      </button>
                      <button
                        className={`px-3 py-1 rounded-full border ${axisSd===10?"bg-slate-900 text-white":"bg-white"}`}
                        onClick={()=>setAxisSd(10)}
                        type="button"
                      >
                        10
                      </button>
                    </div>
                  </div>

                  <div className="flex items-center justify-between mt-4">
                    <label className="text-sm">Curve Color</label>
                    <input
                      type="color"
                      value={curveColor}
                      onChange={(e)=>setCurveColor(e.target.value)}
                      className="w-10 h-8 rounded-md border cursor-pointer"
                    />
                  </div>

                  <label className="mt-3 flex items-center gap-2 text-sm">
                    <input type="checkbox" checked={showBands} onChange={(e)=>setShowBands(e.target.checked)} />
                    Show background bands
                  </label>

                  <label className="mt-2 flex items-center gap-2 text-sm">
                    <input type="checkbox" checked={showNumeric} onChange={(e)=>setShowNumeric(e.target.checked)} />
                    Show numeric scores on markers
                  </label>

                  <label className="mt-2 flex items-center gap-2 text-sm">
                    <input type="checkbox" checked={groupByCluster} onChange={(e)=>setGroupByCluster(e.target.checked)} />
                    Group markers by cluster
                  </label>

                  <div className="mt-3">
                    <label className="text-sm block mb-1">Band language</label>
                    <select className="w-full px-3 py-2 rounded-xl border" value={lang} onChange={(e)=>setLang(e.target.value)}>
                      <option value="en">English</option>
                      <option value="es">Español</option>
                      <option value="yue">粵語 (Cantonese)</option>
                    </select>
                  </div>
                </div>

                <form onSubmit={addItem} className="p-4 rounded-2xl bg-white shadow-sm border lg:col-span-2">
                  <div className="grid md:grid-cols-6 gap-3 items-end">
                    <div className="md:col-span-2">
                      <label className="text-sm">Subtest / Composite name</label>
                      <input className="mt-1 w-full px-3 py-2 rounded-xl border" value={name} onChange={(e)=>setName(e.target.value)} required />
                    </div>

                    <div className="md:col-span-2">
                      <label className="text-sm">Cluster (e.g., WISC-V, Language)</label>
                      <input className="mt-1 w-full px-3 py-2 rounded-xl border" value={cluster} onChange={(e)=>setCluster(e.target.value)} placeholder="Ungrouped if blank" />
                      {clusterOrder.length > 0 && (
                        <div className="text-xs text-slate-500 mt-1">
                          Existing: {clusterOrder.slice(0,6).join(", ")}{clusterOrder.length>6 ? "…" : ""}
                        </div>
                      )}
                    </div>

                    <div>
                      <label className="text-sm">Score type</label>
                      <select className="mt-1 w-full px-3 py-2 rounded-xl border" value={type} onChange={(e)=>setType(e.target.value)}>
                        <option value="standard">Standard (mean 100)</option>
                        <option value="t">T (mean 50, SD 10)</option>
                        <option value="scaled">Scaled (mean 10, SD 3)</option>
                        <option value="z">SD units (z)</option>
                      </select>
                    </div>

                    <div>
                      <label className="text-sm">Value</label>
                      <input type="number" step="any" className="mt-1 w-full px-3 py-2 rounded-xl border" value={value} onChange={(e)=>setValue(e.target.value)} required />
                    </div>

                    <div>
                      <label className="text-sm">Marker Color</label>
                      <select className="mt-1 w-full px-3 py-2 rounded-xl border" value={markerPreset} onChange={(e)=>setMarkerPreset(e.target.value)}>
                        {MARKER_COLOR_PRESETS.map(opt => (
                          <option key={opt.label} value={opt.value}>{opt.label}</option>
                        ))}
                      </select>
                      <div className="text-xs text-slate-500 mt-1">
                        Tip: leave on <span className="font-medium">Auto</span> to use the cluster’s default color.
                      </div>
                    </div>

                    <div className="md:col-span-6 flex justify-end">
                      <button type="submit" className="h-[42px] px-4 rounded-xl bg-slate-900 text-white hover:bg-slate-800">
                        Add
                      </button>
                    </div>
                  </div>

                  {items.length > 0 && (
                    <div className="mt-3 flex flex-wrap gap-2">
                      {items.map(it => (
                        <span key={it.id} className="px-3 py-1 rounded-full bg-slate-100 border text-sm flex items-center gap-2">
                          <span className="inline-block w-3 h-3 rounded-full" style={{background: it.color}} />
                          {it.name} — {it.inputValue} {it.inputType} ({it.cluster || "Ungrouped"})
                          <button onClick={() => removeItem(it.id)} className="ml-1 text-slate-500 hover:text-red-600" title="Remove" type="button">×</button>
                        </span>
                      ))}
                    </div>
                  )}
                </form>
              </div>

              <div className="print-keep">
                <div className="rounded-2xl bg-white shadow-sm border overflow-hidden">
                  <svg width={width} height={height} className="w-full">
                    {showBands && RANGE_BANDS.map((b, idx) => {
                      const x1 = Math.max(xMin, Number.isFinite(b.min) ? b.min : xMin);
                      const x2 = Math.min(xMax, Number.isFinite(b.max) ? b.max : xMax);
                      const X = xScale(x1);
                      const W = xScale(x2) - xScale(x1);
                      return (
                        <g key={idx}>
                          <rect x={X} y={topPad} width={W} height={innerHeight} fill={b.tint} opacity={0.35} />
                          <text x={X + W/2} y={topPad - 6} textAnchor="middle" className="fill-slate-600 text-[12px]">
                            {b.label}
                          </text>
                        </g>
                      );
                    })}

                    <path d={pathD} fill={curveColor} stroke="#0f172a22" strokeWidth={1} />

                    {renderClusterLabels()}

                    {layout.clusters.flatMap((c) =>
                      c.placed.map((it) => {
                        const label = it.name;
                        const val = Math.round(it.std100);
                        const cat = bandFor(it.std100);
                        const fill = it.color;

                        const boxW = it.boxW ?? Math.max(84, String(label).length * 6 + 24);
                        const aX = it.x;
                        const aY = topPad + topRowGap + (it.row * rowGapY) + (it.clusterYOffsetPx || 0);

                        return (
                          <g key={it.id}>
                            <rect x={aX} y={aY} width={boxW} height={boxH} rx={10} ry={10} fill={fill} />
                            <text x={aX + boxW/2} y={aY + 15} textAnchor="middle" className="fill-white text-[12px] font-medium">
                              {label}
                            </text>
                            <text x={aX + boxW/2} y={aY + 28} textAnchor="middle" className="fill-white text-[11px]">
                              {showNumeric ? `${val} • ${cat}` : `${cat}`}
                            </text>
                          </g>
                        );
                      })
                    )}
                  </svg>
                </div>

                {items.length > 0 && (
                  <div className="mt-8 bg-white rounded-2xl shadow-sm border p-4" id="scoreTable">
                    <div className="flex justify-between items-center mb-3">
                      <h2 className="text-lg font-semibold">Entered Scores</h2>
                      <button onClick={()=>window.print()} className="px-4 py-2 bg-slate-900 text-white rounded-lg hover:bg-slate-800 no-print">
                        Print / Save as PDF
                      </button>
                    </div>

                    <table className="min-w-full border border-slate-200 text-sm">
                      <thead className="bg-slate-100">
                        <tr>
                          <th className="border p-2 text-left">Cluster</th>
                          <th className="border p-2 text-left">Subtest / Composite</th>
                          <th className="border p-2 text-left">Score Type</th>
                          <th className="border p-2 text-left">Input Value</th>
                          <th className="border p-2 text-left">Converted (Std-100)</th>
                          <th className="border p-2 text-left">Category</th>
                          <th className="border p-2 text-left">Color</th>
                          <th className="border p-2 text-left">Remove</th>
                        </tr>
                      </thead>
                      <tbody>
                        {items.map(it => (
                          <tr key={it.id}>
                            <td className="border p-2">{it.cluster || "Ungrouped"}</td>
                            <td className="border p-2">{it.name}</td>
                            <td className="border p-2">{it.inputType}</td>
                            <td className="border p-2">{it.inputValue}</td>
                            <td className="border p-2">{Math.round(it.std100)}</td>
                            <td className="border p-2">{bandFor(it.std100)}</td>
                            <td className="border p-2">
                              <span className="inline-block w-5 h-5 rounded-md border" style={{background: it.color}}></span>
                            </td>
                            <td className="border p-2">
                              <button onClick={()=>removeItem(it.id)} className="px-2 py-1 rounded-md border hover:bg-red-50 hover:text-red-700" type="button">
                                Remove
                              </button>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}

              </div>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<BellCurveDashboard />);
    </script>
  </body>
</html>
