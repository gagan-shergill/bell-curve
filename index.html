<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Interactive Normal Distribution</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body { font-family: Georgia, "Times New Roman", Times, serif; }

      @page { size: landscape; margin: 0.5in; }

      @media print {
        body * { visibility: hidden; }
        .print-keep, .print-keep * { visibility: visible; }
        .print-keep { position: static; width: 100%; margin: 0; padding: 0; }
        .print-keep .rounded-2xl { overflow: visible !important; box-shadow: none !important; border-color: #ccc !important; }
        svg { width: 100%; height: auto; }
        table { page-break-before: avoid; width: 100%; border-collapse: collapse; font-size: 10pt; }
        th, td { border: 1px solid #ccc; padding: 4px; }
        .no-print, .print-hide { display: none !important; }
      }
    </style>
  </head>

  <body class="bg-white">
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useState } = React;

      function gaussian(x, mean, sd) {
        const coef = 1 / (sd * Math.sqrt(2 * Math.PI));
        const exp = Math.exp(-0.5 * Math.pow((x - mean) / sd, 2));
        return coef * exp;
      }

      function toStd100(value, type, axisSd) {
        if (type === "standard") return value;
        if (type === "z") return 100 + value * axisSd;
        if (type === "t") return 100 + ((value - 50) / 10) * axisSd;
        if (type === "scaled") return 100 + ((value - 10) / 3) * axisSd;
        return value;
      }

      const BAND_LABELS = {
        en: ["Very Low","Low","Below Avg","Average","High Avg","Very High","Superior"],
        es: ["Muy Bajo","Bajo","Promedio Bajo","Promedio","Promedio Alto","Superior","Muy Superior"],
        yue: ["非常低","低","低平均水平","平均","高平均水平","高","非常高"],
      };

      const BAND_TINTS = ["#fecaca","#fed7aa","#fde68a","#bbf7d0","#bae6fd","#c7d2fe","#ddd6fe"];

      // z-cutpoints matching original 15-SD boundaries (69/79/89/109/119/129)
      const Z_CUTS = [-2, -1.3333333333, -0.6666666667, 0.6666666667, 1.3333333333, 2];

      const CLUSTER_PALETTE = [
        "#0ea5ff", "#6366f1", "#8b5cf6", "#14b8a6", "#22c55e",
        "#f59e0b", "#f97316", "#f43f5e", "#334155"
      ];

      const MARKER_COLOR_PRESETS = [
        { label: "Auto (cluster color)", value: "" },
        { label: "Blue", value: "#0ea5ff" },
        { label: "Indigo", value: "#6366f1" },
        { label: "Violet", value: "#8b5cf6" },
        { label: "Teal", value: "#14b8a6" },
        { label: "Green", value: "#22c55e" },
        { label: "Amber", value: "#f59e0b" },
        { label: "Orange", value: "#f97316" },
        { label: "Rose", value: "#f43f5e" },
        { label: "Slate", value: "#334155" },
      ];

      function BellCurveDashboard() {
        const mean = 100;

        const [axisSd, setAxisSd] = useState(15);
        const [curveColor, setCurveColor] = useState("#bfe0ff99");

        const [name, setName] = useState("");
        const [cluster, setCluster] = useState("");
        const [type, setType] = useState("standard");
        const [value, setValue] = useState("");

        const [items, setItems] = useState([]);
        const [showBands, setShowBands] = useState(false);
        const [showNumeric, setShowNumeric] = useState(true);
        const [lang, setLang] = useState("en");

        const [groupByCluster, setGroupByCluster] = useState(true);
        const [markerPreset, setMarkerPreset] = useState(""); // persists until changed

        const [clusterColors, setClusterColors] = useState({});
        const [clusterOrder, setClusterOrder] = useState([]);

        // SD-dependent bands (so categories change when SD toggles)
        const RANGE_BANDS = useMemo(() => {
          const labels = BAND_LABELS[lang] || BAND_LABELS.en;
          const cuts = Z_CUTS.map(z => mean + z * axisSd);
          return [
            { min: -Infinity, max: cuts[0], label: labels[0], tint: BAND_TINTS[0] },
            { min: cuts[0], max: cuts[1], label: labels[1], tint: BAND_TINTS[1] },
            { min: cuts[1], max: cuts[2], label: labels[2], tint: BAND_TINTS[2] },
            { min: cuts[2], max: cuts[3], label: labels[3], tint: BAND_TINTS[3] },
            { min: cuts[3], max: cuts[4], label: labels[4], tint: BAND_TINTS[4] },
            { min: cuts[4], max: cuts[5], label: labels[5], tint: BAND_TINTS[5] },
            { min: cuts[5], max: Infinity, label: labels[6], tint: BAND_TINTS[6] },
          ];
        }, [lang, axisSd]);

        function bandFor(std100) {
          const b = RANGE_BANDS.find(bb => std100 >= bb.min && std100 <= bb.max);
          return b ? b.label : "";
        }

        // Shift curve right / prevent left labels clipping
        const width = 1000;
        const leftPad = 150;
        const rightPad = 40;
        const innerWidth = width - leftPad - rightPad;

        const xMin = 40;
        const xMax = 160;

        const rowGapY = 38;
        const boxH = 36;
        const boxGapX = 8;
        const clusterGapY = 22;

        const topPad = 24;
        const bottomPad = 70;
        const baseHeight = 400;
        const topRowGap = 16;

        const xScale = (x) => leftPad + ((x - xMin) / (xMax - xMin)) * innerWidth;

        function ensureClusterColor(clusterName) {
          const clean = (clusterName || "").trim();
          const key = clean || "Ungrouped";
          if (clusterColors[key]) return { key, color: clusterColors[key] };

          const nextIdx = clusterOrder.length % CLUSTER_PALETTE.length;
          const nextColor = CLUSTER_PALETTE[nextIdx];

          setClusterColors(prev => ({ ...prev, [key]: nextColor }));
          setClusterOrder(prev => (prev.includes(key) ? prev : [...prev, key]));

          return { key, color: nextColor };
        }

        // recompute std100 live based on current axisSd
        const displayItems = useMemo(() => {
          return items.map(it => ({
            ...it,
            std100: toStd100(it.inputValue, it.inputType, axisSd)
          }));
        }, [items, axisSd]);

        function addItem(e) {
          e.preventDefault();
          const num = Number(value);
          if (!isFinite(num)) return;

          const { key, color } = ensureClusterColor(cluster);
          const finalColor = markerPreset ? markerPreset : color;

          setItems(prev => ([
            ...prev,
            {
              id: Math.random().toString(36).slice(2),
              name: name.trim() || "(Unnamed)",
              cluster: key,
              inputType: type,
              inputValue: num,
              color: finalColor,
            }
          ]));

          setName("");
          setValue("");
        }

        function removeItem(id) {
          setItems(prev => prev.filter(i => i.id !== id));
        }

        // Marker packing (keeps clusters separate vertically)
        const layout = useMemo(() => {
          const getBoxW = (label) => Math.max(84, String(label).length * 6 + 24);

          function packRows(clusterItems) {
            const sorted = [...clusterItems].sort((a,b) => a.std100 - b.std100);
            const rowsRight = [];
            const placed = [];

            sorted.forEach((it) => {
              const x = xScale(it.std100);
              const boxW = getBoxW(it.name);
              const proposedX = Math.max(
                leftPad + 4,
                Math.min(x - boxW / 2, leftPad + innerWidth - boxW - 4)
              );

              let row = 0;
              while (true) {
                const rightEdge = rowsRight[row] ?? (leftPad - boxGapX);
                if (proposedX >= rightEdge + boxGapX) {
                  rowsRight[row] = proposedX + boxW;
                  placed.push({ ...it, boxW, x: proposedX, row });
                  break;
                }
                row += 1;
              }
            });

            return { placed, rows: Math.max(1, rowsRight.length) };
          }

          if (!groupByCluster) {
            const { placed, rows } = packRows(displayItems);
            return { totalRows: rows, clusters: [{ name: "__all__", rows, yOffsetPx: 0, placed }] };
          }

          const clustersMap = new Map();
          displayItems.forEach((it) => {
            const key = it.cluster || "Ungrouped";
            if (!clustersMap.has(key)) clustersMap.set(key, []);
            clustersMap.get(key).push(it);
          });

          const orderedClusters = [
            ...clusterOrder.filter(c => clustersMap.has(c)),
            ...[...clustersMap.keys()].filter(c => !clusterOrder.includes(c)).sort()
          ];

          let yOffsetRows = 0;
          const clusterLayouts = [];

          orderedClusters.forEach((cname, idx) => {
            const { placed, rows } = packRows(clustersMap.get(cname));
            const gap = (idx === 0) ? 0 : clusterGapY;
            const yOffsetPx = yOffsetRows * rowGapY + gap;

            clusterLayouts.push({
              name: cname,
              rows,
              yOffsetPx,
              placed: placed.map(p => ({ ...p, clusterYOffsetPx: yOffsetPx }))
            });

            yOffsetRows += rows;
          });

          return { totalRows: yOffsetRows, clusters: clusterLayouts };
        }, [displayItems, groupByCluster, clusterOrder, leftPad, innerWidth]);

        const height = useMemo(() => {
          if (!displayItems.length) return baseHeight;

          const required =
            topPad + topRowGap +
            (layout.totalRows * rowGapY) +
            boxH + bottomPad + (groupByCluster ? 10 : 0);

          return Math.max(baseHeight, required);
        }, [displayItems.length, layout.totalRows, groupByCluster]);

        const innerHeight = height - topPad - bottomPad;

        const pathD = useMemo(() => {
          const steps = 300;
          let maxY = 0;
          const xs = [];
          const ys = [];
          for (let i = 0; i <= steps; i++) {
            const x = xMin + (i * (xMax - xMin)) / steps;
            const y = gaussian(x, mean, axisSd);
            xs.push(x); ys.push(y);
            if (y > maxY) maxY = y;
          }

          const scaleY = (y) => topPad + innerHeight - (y / maxY) * innerHeight;

          let d = "";
          for (let i = 0; i <= steps; i++) {
            const X = xScale(xs[i]);
            const Y = scaleY(ys[i]);
            d += i === 0 ? `M ${X} ${Y}` : ` L ${X} ${Y}`;
          }
          d += ` L ${xScale(xMax)} ${topPad + innerHeight} L ${xScale(xMin)} ${topPad + innerHeight} Z`;
          return d;
        }, [axisSd, innerHeight, leftPad, innerWidth]);

        function renderClusterLabels() {
          if (!groupByCluster) return null;
          return layout.clusters.map((c) => (
            <text
              key={c.name}
              x={leftPad - 18}
              y={topPad + topRowGap + c.yOffsetPx + 12}
              textAnchor="end"
              className="fill-slate-500 text-[11px]"
            >
              {c.name}
            </text>
          ));
        }

        return (
          <div className="w-full min-h-screen bg-white text-slate-800 p-6">
            <div className="max-w-[1200px] mx-auto">
              <h1 className="text-2xl md:text-3xl font-semibold mb-2 print-hide">
                Interactive Normal Distribution
              </h1>

              <div className="grid lg:grid-cols-3 gap-4 mb-6 print-hide">
                <div className="p-4 rounded-2xl bg-white shadow-sm border">
                  <div className="flex items-center justify-between mb-3">
                    <span className="font-medium">Axis standard deviation</span>
                    <div className="flex items-center gap-2">
                      <button
                        type="button"
                        className={`px-3 py-1 rounded-full border ${axisSd===15?"bg-slate-900 text-white":"bg-white"}`}
                        onClick={() => setAxisSd(15)}
                      >15</button>
                      <button
                        type="button"
                        className={`px-3 py-1 rounded-full border ${axisSd===10?"bg-slate-900 text-white":"bg-white"}`}
                        onClick={() => setAxisSd(10)}
                      >10</button>
                    </div>
                  </div>

                  <div className="flex items-center justify-between mt-4">
                    <label className="text-sm">Curve Color</label>
                    <input
                      type="color"
                      value={curveColor}
                      onChange={(e)=>setCurveColor(e.target.value)}
                      className="w-10 h-8 rounded-md border cursor-pointer"
                    />
                  </div>

                  <label className="mt-3 flex items-center gap-2 text-sm">
                    <input
                      type="checkbox"
                      checked={showBands}
                      onChange={(e)=>setShowBands(e.target.checked)}
                    />
                    Show background bands
                  </label>

                  <label className="mt-2 flex items-center gap-2 text-sm">
                    <input
                      type="checkbox"
                      checked={showNumeric}
                      onChange={(e)=>setShowNumeric(e.target.checked)}
                    />
                    Show numeric scores on markers
                  </label>

                  <label className="mt-2 flex items-center gap-2 text-sm">
                    <input
                      type="checkbox"
                      checked={groupByCluster}
                      onChange={(e)=>setGroupByCluster(e.target.checked)}
                    />
                    Group markers by cluster
                  </label>

                  <div className="mt-3">
                    <label className="text-sm block mb-1">Band language</label>
                    <select
                      className="w-full px-3 py-2 rounded-xl border"
                      value={lang}
                      onChange={(e)=>setLang(e.target.value)}
                    >
                      <option value="en">English</option>
                      <option value="es">Español</option>
                      <option value="yue">粵語 (Cantonese)</option>
                    </select>
                  </div>
                </div>

                <form onSubmit={addItem} className="p-4 rounded-2xl bg-white shadow-sm border lg:col-span-2">
                  <div className="grid md:grid-cols-6 gap-3 items-end">
                    <div className="md:col-span-2">
                      <label className="text-sm">Subtest / Composite name</label>
                      <input
                        className="mt-1 w-full px-3 py-2 rounded-xl border"
                        value={name}
                        onChange={(e)=>setName(e.target.value)}
                        required
                      />
                    </div>

                    <div className="md:col-span-2">
                      <label className="text-sm">Cluster (e.g., WISC-V, Language)</label>
                      <input
                        className="mt-1 w-full px-3 py-2 rounded-xl border"
                        value={cluster}
                        onChange={(e)=>setCluster(e.target.value)}
                        placeholder="Ungrouped if blank"
                      />
                    </div>

                    <div>
                      <label className="text-sm">Score type</label>
                      <select
                        className="mt-1 w-full px-3 py-2 rounded-xl border"
                        value={type}
                        onChange={(e)=>setType(e.target.value)}
                      >
                        <option value="standard">Standard (mean 100)</option>
                        <option value="t">T (mean 50, SD 10)</option>
                        <option value="scaled">Scaled (mean 10, SD 3)</option>
                        <option value="z">SD units (z)</option>
                      </select>
                    </div>

                    <div>
                      <label className="text-sm">Value</label>
                      <input
                        type="number"
                        step="any"
                        className="mt-1 w-full px-3 py-2 rounded-xl border"
                        value={value}
                        onChange={(e)=>setValue(e.target.value)}
                        required
                      />
                    </div>

                    <div>
                      <label className="text-sm">Marker Color</label>
                      <select
                        className="mt-1 w-full px-3 py-2 rounded-xl border"
                        value={markerPreset}
                        onChange={(e)=>setMarkerPreset(e.target.value)}
                      >
                        {MARKER_COLOR_PRESETS.map(opt => (
                          <option key={opt.label} value={opt.value}>{opt.label}</option>
                        ))}
                      </select>
                      <div className="text-xs text-slate-500 mt-1">
                        Leave on <span className="font-medium">Auto</span> to use the cluster’s default color.
                      </div>
                    </div>

                    <div className="md:col-span-6 flex justify-end">
                      <button type="submit" className="h-[42px] px-4 rounded-xl bg-slate-900 text-white hover:bg-slate-800">
                        Add
                      </button>
                    </div>
                  </div>

                  {displayItems.length > 0 && (
                    <div className="mt-3 flex flex-wrap gap-2">
                      {displayItems.map(it => (
                        <span
                          key={it.id}
                          className="px-3 py-1 rounded-full bg-slate-100 border text-sm flex items-center gap-2"
                        >
                          <span className="inline-block w-3 h-3 rounded-full" style={{background: it.color}} />
                          {it.name} — {it.inputValue} {it.inputType} ({it.cluster || "Ungrouped"})
                          <button
                            type="button"
                            onClick={() => removeItem(it.id)}
                            className="ml-1 text-slate-500 hover:text-red-600"
                            title="Remove"
                          >
                            ×
                          </button>
                        </span>
                      ))}
                    </div>
                  )}
                </form>
              </div>

              <div className="print-keep">
                <div className="rounded-2xl bg-white shadow-sm border overflow-hidden">
                  <svg width={width} height={height} className="w-full">
                    {showBands && RANGE_BANDS.map((b, idx) => {
                      const x1 = Math.max(xMin, Number.isFinite(b.min) ? b.min : xMin);
                      const x2 = Math.min(xMax, Number.isFinite(b.max) ? b.max : xMax);
                      const X = xScale(x1);
                      const W = xScale(x2) - xScale(x1);

                      const cx = X + W / 2;
                      const cy = topPad - 6;

                      // ✅ One line always; for SD=10 we rotate slightly + shrink font to avoid overlap
                      const rotateDeg = axisSd === 10 ? -18 : 0;

                      return (
                        <g key={idx}>
                          <rect x={X} y={topPad} width={W} height={innerHeight} fill={b.tint} opacity={0.35} />
                          <text
                            x={cx}
                            y={cy}
                            textAnchor="middle"
                            transform={rotateDeg ? `rotate(${rotateDeg} ${cx} ${cy})` : undefined}
                            className={`fill-slate-600 ${axisSd === 10 ? "text-[10px]" : "text-[12px]"}`}
                          >
                            {b.label}
                          </text>
                        </g>
                      );
                    })}

                    <path d={pathD} fill={curveColor} stroke="#0f172a22" strokeWidth={1} />

                    {renderClusterLabels()}

                    {layout.clusters.flatMap((c) =>
                      c.placed.map((it) => {
                        const val = Math.round(it.std100);
                        const cat = bandFor(it.std100);

                        const boxW = it.boxW;
                        const aX = it.x;
                        const aY = topPad + topRowGap + (it.row * rowGapY) + (it.clusterYOffsetPx || 0);

                        return (
                          <g key={it.id}>
                            <rect x={aX} y={aY} width={boxW} height={boxH} rx={10} ry={10} fill={it.color} />
                            <text x={aX + boxW/2} y={aY + 15} textAnchor="middle" className="fill-white text-[12px] font-medium">
                              {it.name}
                            </text>
                            <text x={aX + boxW/2} y={aY + 28} textAnchor="middle" className="fill-white text-[11px]">
                              {showNumeric ? `${val} • ${cat}` : `${cat}`}
                            </text>
                          </g>
                        );
                      })
                    )}
                  </svg>
                </div>

                {displayItems.length > 0 && (
                  <div className="mt-8 bg-white rounded-2xl shadow-sm border p-4" id="scoreTable">
                    <div className="flex justify-between items-center mb-3">
                      <h2 className="text-lg font-semibold">Entered Scores</h2>
                      <button
                        type="button"
                        onClick={()=>window.print()}
                        className="px-4 py-2 bg-slate-900 text-white rounded-lg hover:bg-slate-800 no-print"
                      >
                        Print / Save as PDF
                      </button>
                    </div>

                    <table className="min-w-full border border-slate-200 text-sm">
                      <thead className="bg-slate-100">
                        <tr>
                          <th className="border p-2 text-left">Cluster</th>
                          <th className="border p-2 text-left">Subtest / Composite</th>
                          <th className="border p-2 text-left">Score Type</th>
                          <th className="border p-2 text-left">Input Value</th>
                          <th className="border p-2 text-left">Converted (Std-100)</th>
                          <th className="border p-2 text-left">Category</th>
                          <th className="border p-2 text-left">Color</th>
                          <th className="border p-2 text-left">Remove</th>
                        </tr>
                      </thead>
                      <tbody>
                        {displayItems.map(it => (
                          <tr key={it.id}>
                            <td className="border p-2">{it.cluster || "Ungrouped"}</td>
                            <td className="border p-2">{it.name}</td>
                            <td className="border p-2">{it.inputType}</td>
                            <td className="border p-2">{it.inputValue}</td>
                            <td className="border p-2">{Math.round(it.std100)}</td>
                            <td className="border p-2">{bandFor(it.std100)}</td>
                            <td className="border p-2">
                              <span className="inline-block w-5 h-5 rounded-md border" style={{background: it.color}}></span>
                            </td>
                            <td className="border p-2">
                              <button
                                type="button"
                                onClick={()=>removeItem(it.id)}
                                className="px-2 py-1 rounded-md border hover:bg-red-50 hover:text-red-700"
                              >
                                Remove
                              </button>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}
              </div>

            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<BellCurveDashboard />);
    </script>
  </body>
</html>
