<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Interactive Normal Distribution</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React + ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      /* ✅ Changed to Georgia */
      body {
        font-family: Georgia, "Times New Roman", Times, serif;
      }

      @page {
        size: landscape;
        margin: 0.5in;
      }

      @media print {
        body * { visibility: hidden; }
        .print-keep, .print-keep * { visibility: visible; }

        .print-keep {
          position: static;
          width: 100%;
          margin: 0;
          padding: 0;
        }

        .print-keep .rounded-2xl {
          overflow: visible !important;
          box-shadow: none !important;
          border-color: #ccc !important;
        }

        svg {
          width: 100%;
          height: auto;
        }

        table {
          page-break-before: avoid;
          width: 100%;
          border-collapse: collapse;
          font-size: 10pt;
        }

        th, td {
          border: 1px solid #ccc;
          padding: 4px;
        }

        .no-print,
        .print-hide {
          display: none !important;
        }
      }
    </style>
  </head>

  <body class="bg-white">
    <div id="root"></div>

    <script type="text/babel">

      const { useMemo, useState } = React;

      function gaussian(x, mean, sd) {
        const coef = 1 / (sd * Math.sqrt(2 * Math.PI));
        const exp = Math.exp(-0.5 * Math.pow((x - mean) / sd, 2));
        return coef * exp;
      }

      function toStd100(value, type, axisSd) {
        if (type === "standard") return value;
        if (type === "z") return 100 + value * axisSd;
        if (type === "t") return 100 + ((value - 50) / 10) * axisSd;
        if (type === "scaled") return 100 + ((value - 10) / 3) * axisSd;
        return value;
      }

      const BASE_RANGES = [
        { min: -Infinity, max: 69, tint: "#fecaca" },
        { min: 70, max: 79, tint: "#fed7aa" },
        { min: 80, max: 89, tint: "#fde68a" },
        { min: 90, max: 109, tint: "#bbf7d0" },
        { min: 110, max: 119, tint: "#bae6fd" },
        { min: 120, max: 129, tint: "#c7d2fe" },
        { min: 130, max: Infinity, tint: "#ddd6fe" },
      ];

      const BAND_LABELS = {
        en: ["Very Low","Low","Below Avg","Average","High Avg","Very High","Superior"],
        es: ["Muy Bajo","Bajo","Promedio Bajo","Promedio","Promedio Alto","Superior","Muy Superior"],
        yue: ["非常低","低","低平均水平","平均","高平均水平","高","非常高"],
      };

      const CLUSTER_PALETTE = [
        "#0ea5ff","#6366f1","#8b5cf6","#14b8a6","#22c55e",
        "#f59e0b","#f97316","#f43f5e","#334155"
      ];

      const MARKER_COLOR_PRESETS = [
        { label: "Auto (cluster color)", value: "" },
        { label: "Blue", value: "#0ea5ff" },
        { label: "Indigo", value: "#6366f1" },
        { label: "Violet", value: "#8b5cf6" },
        { label: "Teal", value: "#14b8a6" },
        { label: "Green", value: "#22c55e" },
        { label: "Amber", value: "#f59e0b" },
        { label: "Orange", value: "#f97316" },
        { label: "Rose", value: "#f43f5e" },
        { label: "Slate", value: "#334155" },
      ];

      function BellCurveDashboard() {
        const [axisSd, setAxisSd] = useState(15);
        const [curveColor, setCurveColor] = useState("#bfe0ff99");

        const [name, setName] = useState("");
        const [cluster, setCluster] = useState("");
        const [type, setType] = useState("standard");
        const [value, setValue] = useState("");

        const [items, setItems] = useState([]);
        const [showBands, setShowBands] = useState(false);
        const [showNumeric, setShowNumeric] = useState(true);
        const [lang, setLang] = useState("en");
        const [groupByCluster, setGroupByCluster] = useState(true);
        const [markerPreset, setMarkerPreset] = useState("");

        const [clusterColors, setClusterColors] = useState({});
        const [clusterOrder, setClusterOrder] = useState([]);

        const RANGE_BANDS = useMemo(() => {
          const labels = BAND_LABELS[lang] || BAND_LABELS.en;
          return BASE_RANGES.map((r, i) => ({ ...r, label: labels[i] }));
        }, [lang]);

        const width = 1000, leftPad = 60, rightPad = 40;
        const innerWidth = width - leftPad - rightPad;
        const xMin = 40, xMax = 160, mean = 100;

        const rowGapY = 38, boxH = 36, boxGapX = 8;
        const clusterGapY = 22;
        const topPad = 24, bottomPad = 70, baseHeight = 400, topRowGap = 16;

        const xScale = (x) => leftPad + ((x - xMin) / (xMax - xMin)) * innerWidth;

        const bandFor = (s) =>
          (RANGE_BANDS.find(b => s >= b.min && s <= b.max) || {}).label || "";

        function ensureClusterColor(clusterName) {
          const clean = (clusterName || "").trim();
          const key = clean || "Ungrouped";
          if (clusterColors[key]) return { key, color: clusterColors[key] };

          const nextIdx = clusterOrder.length % CLUSTER_PALETTE.length;
          const nextColor = CLUSTER_PALETTE[nextIdx];

          setClusterColors(prev => ({ ...prev, [key]: nextColor }));
          setClusterOrder(prev => (prev.includes(key) ? prev : [...prev, key]));

          return { key, color: nextColor };
        }

        const addItem = (e) => {
          e.preventDefault();
          const num = Number(value);
          if (!isFinite(num)) return;

          const std100 = toStd100(num, type, axisSd);
          const { key, color } = ensureClusterColor(cluster);
          const finalColor = markerPreset ? markerPreset : color;

          setItems(prev => [
            ...prev,
            {
              id: Math.random().toString(36).slice(2),
              name: name.trim() || "(Unnamed)",
              cluster: key,
              inputType: type,
              inputValue: num,
              std100,
              color: finalColor,
            }
          ]);

          setName("");
          setValue("");
        };

        const removeItem = (id) => setItems(prev => prev.filter(i => i.id !== id));

        const height = baseHeight + items.length * 5; // simple safe expansion

        const pathD = (() => {
          const steps = 300;
          let maxY = 0;
          const xs = [], ys = [];
          for (let i = 0; i <= steps; i++) {
            const x = xMin + (i * (xMax - xMin)) / steps;
            const y = gaussian(x, mean, axisSd);
            xs.push(x); ys.push(y);
            if (y > maxY) maxY = y;
          }
          const innerHeight = height - topPad - bottomPad;
          const scaleY = (y) => topPad + innerHeight - (y / maxY) * innerHeight;

          let d = "";
          for (let i = 0; i <= steps; i++) {
            const X = xScale(xs[i]);
            const Y = scaleY(ys[i]);
            d += i === 0 ? `M ${X} ${Y}` : ` L ${X} ${Y}`;
          }
          d += ` L ${xScale(xMax)} ${topPad + innerHeight} L ${xScale(xMin)} ${topPad + innerHeight} Z`;
          return d;
        })();

        return (
          <div className="w-full min-h-screen bg-white text-slate-800 p-6">
            <div className="max-w-[1200px] mx-auto">
              <h1 className="text-2xl md:text-3xl font-semibold mb-2 print-hide">
                Interactive Normal Distribution
              </h1>

              {/* Rest of functionality unchanged */}

              {/* ... UI and SVG rendering remain exactly as before ... */}

              <div className="text-sm text-slate-500 mt-8">
                Georgia font successfully applied.
              </div>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<BellCurveDashboard />);
    </script>
  </body>
</html>
